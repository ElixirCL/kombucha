= The Kombucha Programming Language
:author: Camilo Castro
:email: camilo@ninjas.cl
:revdate: 2023-03-27
:revremark: work in progress
:doctype: article 
:listing-caption: Listing
:sectnums:
:toc: left
:toc: macro
:toclevels: 3
:ext-relative:

toc::[]

== Introduction
_Kombucha_ is a functional programming language inspired by <<Elixir>>, <<Gleam>>, <<Wren>>, <<Swift>>, <<Lox>> and others.

- High level language.
- Dynamically typed.
- Optional types (for helping linters).

.Kombucha example with Hello World
[[kc-hello-example]]
[source,kombucha]
----
module Hello.World {
    pub fn salute() {
        IO.puts("Hello World")
    }
}

Hello.World.salute()
----

== Compilation and Execution

The objective of Kombucha language is generating a standarized _AST_ in _JSON_{empty}footnote:[https://www.json.org/]. That other programming language can read, transform and execute. For example you can use _Racket_{empty}footnote:[https://racket-lang.org/] or _Erlang_{empty}footnote:[https://www.erlang.org/doc/apps/erts/absform.html] to read the final _JSON AST_ file and transform it to another _AST_ format and finally execute it. This is similar to Elixir Compilation Steps{empty}footnote:[https://medium.com/@fxn/how-does-elixir-compile-execute-code-c1b36c9ec8cf].

=== Compilation Workflow

Main phases of _Kombucha_ Compilation.

```mermaid
flowchart TD
    A[Scan] --> B[Parse]
    B --> C{Expand}
    C --> D(Is Done Expanding?)
    D --> |No| C
    D -->|Yes| F[Generate JSON AST]
```

1. Load the contents of the file in memory.
2. Produce an AST from it using a custom tokenizer.
3. Expand the AST with transformations.
4. Transform that final AST into _JSON_.

=== Execution Workflow

This would depend on the target language. For example if we would like to use _Erlang_ as the target language.

1. Read JSON AST from Compilation Workflow.
2. Transform it to _Erlang Abstract Format_.
3. Create a function called `__FILE__/1` in a module called `_kombucha_compiler_x`, where `x` is an integer. The function will contain the AST from step 2.
4. Compile the result to BEAM assembly on the fly with `compile:forms/2`{empty}footnote:[https://www.erlang.org/doc/man/compile.html#forms-2], which returns a binary (no file is written).
5. Load said binary into the Erlang VM using the Erlang code server{empty}footnote:[https://www.erlang.org/doc/man/code.html].
6. Call `elixir_compiler_X.__FILE__/1`. This function has the whole program as body, the VM is effectively running the program.

=== Command Line

- `kombucha build`: Generates a single amalgamated `AST.kombucha.json` file.
- `kombucha build --target=erlang`: Generates a json file and also a `beam` compile file.
- `kombucha compile`: Generates multiple json compiled files. One for each module (even if they are in the same file).
- `kombucha compile --target=erlang`: Generates multiple json and beam compiled files.
- `kombucha format`: Formats the source file.
- `kombucha run --target=erlang`: Compiles then runs the file with the target language.
- `kombucha docs`: Creates markdown documentation files by parsing comments inside modules.

== Syntax

Kombucha’s syntax is designed to be familiar to people coming from C-like languages
with some ideas taken from `Elixir` and friends.

Scripts are stored in plain text files with a `.kc` and `.kcs` file extension (although is just a convention).

=== Comments

==== Single Line Comment
In Kombucha, comments must start with two slashes (`//`) and continue until the end of the line.

.Example
`// This is a Comment`

For comments that extend beyond a single line, you’ll need to include `//` on each line, like this:

```text
// Hello, world! I have a lot to say, so much that it will take multiple
// lines of text. Therefore, I will start each line with // to denote it
// as part of a multi-line comment.
```

Comments can also be placed at the end of lines containing code:

```kombucha
pub fn add(x, y) {
  x + y // here we are adding two values together
}
```

Comments may also be indented:

```kombucha
pub fn multiply(x, y) {
  // here we are multiplying x by y
  x * y
}
```

==== Multi-line Comments
Block comments start with `/\*` and end with `*/`. They can span multiple lines:

```kombucha
/* This
   is
   a
   multi-line
   comment. */
```

Unlike C, block comments can nest in Kombucha:

`/* This is /* a nested */ comment. */`

This is handy because it lets you easily comment out an entire block of code, even if the code already contains block comments.

===== Code Annotations

Using `// MARK:` can help IDES to mark special places in the code.
_MARK_ can be with and without a hyphen (`-`). If the hyphen is present it will signal to be a subsection of the previous `MARK:`.

There is also `TODO:`, `FIXME:` and `PRAGMA:` marks.

.Examples
- `// MARK: My Section`.
- `// MARK: - My Sub Section`.
- `// TODO: This must be completed later`.
- `// FIXME: There is something wrong here`.
- `// PRAGMA: compiler-directive`.

==== Markup Comments

Markup coments are inspired by _Swift_{blank}footnote:[https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html#//apple_ref/doc/uid/TP40016497-CH2-SW1]. They use CommonMark{blank}footnote:[https://commonmark.org/] to help documentation generation.
Kombucha Markup syntax is exactly CommonMark, by design, not only for its straightforward implementation and completeness but also in the spirit of Markdown's readability through limited special syntax.

- `///`: Single line markup comment. (function scope).
- `////`: Single line markup comment. (module scope).
- `//:`: Single line markup comment. (any scope).
- `/**`: Multi line markup comment. (function scope).
- `/*!`: Multi line markup comment. (module scope).
- `/*:`: Multi line markup comment. (any scope).

==== Documentation Comments

Follows _Swift Documentation Comments_{blank}footnote:[https://github.com/apple/swift/blob/main/docs/DocumentationComments.md]

.Example
```markdown
- Parameters:
  - x: ...
  - y: ...
  - z: ...
```

[appendix]
== Glossary

AST::
    Abstract Syntax Tree

[appendix]
// [bibliography]
== References

- [[[Elixir]]] The Elixir Team. (2011). The Elixir Programming Language. https://elixir-lang.org/ (accessed 2023-03-27).

- [[[Gleam]]] Louis Pilfold. (2019). The Gleam Programming Language. https://gleam.run/ (accessed 2023-03-27).

- [[[Wren]]] Bob Nystrom. (2013). The Wren Programming Language. https://wren.io/ (accessed 2023-03-27).

- [[[Lox]]] Bob Nystrom. (2014). The Lox Programming Language. https://craftinginterpreters.com/the-lox-language.html (accessed 2023-03-27).

- [[[Swift]]] Apple (2014). https://www.swift.org/ (accessed 2023-03-29).
